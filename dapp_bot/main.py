import asyncio

from aiogram import Bot, Dispatcher, executor
from aiogram.dispatcher import FSMContext
# from aiogram.dispatcher.filters.state import StatesGroup
from aiogram.contrib.fsm_storage.memory import MemoryStorage
from aiogram.types import Message, CallbackQuery, ChatType

from config import token, db_params, infura_id
from middleware.i18n import i18n, _
from ethereum import EthereumApi
from tron import TronApi
from exceptions import *
from db import CacheDB
from buttons import *
from utils import reduction_addr

bot = Bot(token, parse_mode='markdown')
storage = MemoryStorage()
dp = Dispatcher(bot, storage=storage)

dp.middleware.setup(i18n)
__ = i18n.lazy_gettext

db = CacheDB()
# db.create_tables(**db_params)
db.create_connection(**db_params)
dp['db'] = db

eth = EthereumApi(infura_id)
trx = TronApi()

list_bch = ['ethereum', 'tron']
bch_modules = {'ethereum': eth,
               'tron': trx}

bch_token_names = {'ethereum': 'ETH',
                   'tron': 'TRX'}


@dp.message_handler(ChatType.is_private, commands=['start'])
async def on_start_msg(msg: Message):
    try:
        await db.save_new_user(msg.from_user.id,
                               msg.from_user.first_name,
                               msg.from_user.username)
    except ExistingUser:  # –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
        text, btn = main_menu()
        await bot.send_message(msg.chat.id, text, reply_markup=btn)
    else:  # –Ω–æ–≤—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å
        await select_language(msg)


def main_menu():
    return _('–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é'), main_menu_btn()


async def select_language(msg):
    await bot.send_message(msg.chat.id, _('–í—ã–±–µ—Ä–∏—Ç–µ —è–∑—ã–∫'),
                           reply_markup=lang_select_inl())


@dp.message_handler(text=__('–ú–æ–∏ –∫–æ—à–µ–ª—å–∫–∏'))
async def on_wallets_btn(msg: Message):
    text, btn = await my_wallets_msg(msg)
    await bot.send_message(msg.chat.id, text, reply_markup=btn)


@dp.message_handler(text=__('–ù–∞—Å—Ç—Ä–æ–π–∫–∏'))
async def on_settings_btn(msg: Message):
    await bot.send_message(msg.chat.id, _('–ù–∞—Å—Ç—Ä–æ–π–∫–∏'), reply_markup=settings_btn())


@dp.message_handler(text=__('–°–º–µ–Ω–∏—Ç—å —è–∑—ã–∫'))
async def on_settings_btn(msg: Message):
    await select_language(msg)


# async def wallets_msg(msg):
#     eth_w, trx_w = await db.get_user_wallets(msg.chat.id)
#     text = _('*–ú–æ–∏ –∫–æ—à–µ–ª—å–∫–∏*') + '\n'
#     text += '\n*Tron:*\n' if trx_w else ''
#     for w in trx_w:
#         text += '‚ûñ`{}`  *{} TRX*\n'.format(reduction_addr(w),
#                                            await trx.get_balance(w))
#
#     text += '\n*Ethereum:*\n' if eth_w else ''
#     for w in eth_w:
#         text += '‚ûñ`{}`  *{} ETH*\n'.format(reduction_addr(w),
#                                            await eth.get_balance(w))
#
#     if len(text.split('\n')) == 3:
#         text += _('–£ –≤–∞—Å –Ω–µ—Ç –¥–æ–±–∞–≤–ª–µ–Ω–Ω—ã—Ö –∫–æ—à–µ–ª—å–∫–æ–≤ üòû')
#         return text, no_full_wallets_inl()
#     return text, full_wallets_inl()


async def my_wallets_msg(msg):
    return _('*–í—ã–±–µ—Ä–∏—Ç–µ –±–ª–æ–∫—á–µ–π–Ω*'), select_bch_inl()


async def my_bch_wallets(msg: CallbackQuery, bch):
    if isinstance(msg, CallbackQuery):
        user_id = msg.message.chat.id
    else:
        user_id = msg.chat.id
    text = _('*–ú–æ–∏ {bch}-–∫–æ—à–µ–ª—å–∫–∏*\n\n').format(bch=bch.capitalize())
    wallets = await db.get_user_wallets(user_id, bch)
    btn = list_wallet_inl(wallets, bch)
    if len(btn.inline_keyboard) <= 2:
        text += _('–£ –≤–∞—Å –Ω–µ—Ç –¥–æ–±–∞–≤–ª–µ–Ω–Ω—ã—Ö –∫–æ—à–µ–ª—å–∫–æ–≤ üòû')
    return text, btn


def select_bch_check(call: CallbackQuery):
    if call.data.endswith('view'):
        return {'bch': call.data.split('_')[0]}  # (ethereum/tron)_select_bch


# def cancel_check(call):
#    print(call.data)
#    if call.data.startswith('cancel'):
#        maybe_msg_id = call.data.split('_')[-1]
#        if maybe_msg_id.isdigit():
#            return {'msg_id': int(maybe_msg_id)}
#        return {'msg_id': None}


# –æ—Ç–º–µ–Ω–∞ –ª—é–±–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è
@dp.callback_query_handler(lambda c: c.data == 'cancel', state='*')
async def on_cancel(call: CallbackQuery):
    await call.message.delete()
    text, btn = main_menu()
    await bot.send_message(call.message.chat.id, text, reply_markup=btn)
    await storage.reset_state(user=call.message.chat.id)


# —Å–ø–∏—Å–æ–∫ —è–∑—ã–∫–æ–≤, –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫ –≤—ã–±–æ—Ä—É
@dp.callback_query_handler(lambda c: c.data in ['ru', 'en'])  # –≤—ã–±–æ—Ä —è–∑—ã–∫–∞
async def on_select_lang(call: CallbackQuery):
    await db.set_user_locale(call.from_user.id, call.data)
    # —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ª–æ–∫–∞–ª—å —è–≤–Ω–æ
    i18n.ctx_locale.set(call.data)
    await call.message.delete()
    text, btn = main_menu()
    await bot.send_message(call.message.chat.id, text, reply_markup=btn)


# –≤—ã–±–æ—Ä –±–ª–æ–∫—á–µ–π–Ω–∞, –∫–æ—à–µ–ª—å–∫–∏ –∫–æ—Ç–æ—Ä–æ–≥–æ —Ö–æ—Ç–∏–º –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å
@dp.callback_query_handler(text='my_wallets')
async def on_wallets_inl(call: CallbackQuery):
    text, btn = await my_wallets_msg(call.message)
    await call.message.edit_text(text, reply_markup=btn)


# —Å–ø–∏—Å–æ–∫ –¥–æ–±–∞–≤–ª–µ–Ω–Ω—ã—Ö –∫–æ—à–µ–ª—å–∫–æ–≤
@dp.callback_query_handler(select_bch_check)
async def on_select_bch(call: CallbackQuery, bch):
    text, btn = await my_bch_wallets(call, bch)
    await call.message.edit_text(text, reply_markup=btn)


def find_address_in_callback_data(call):
    if call.data.endswith('address_info'):
        bch, wallet_id = call.data.split('_')[:2]
        module = bch_modules[bch]
        return {'bch': bch, 'module': module, 'wallet_id': int(wallet_id)}


# –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –∫–æ—à–µ–ª—å–∫–µ
@dp.callback_query_handler(find_address_in_callback_data)
async def on_view_address(call, bch, module, wallet_id):
    address = await db.get_address_by_id(call.message.chat.id, wallet_id)
    balance = await module.get_balance(address)
    text = _('*–ö–æ—à–µ–ª–µ–∫ {}*').format(bch.capitalize()) + '\n'
    text += '`{}`'.format(address) + '\n\n'
    text += _('*–ë–∞–ª–∞–Ω—Å: *') + '`{}` *{}*'.format(balance, bch_token_names[bch])
    await call.message.edit_text(text, reply_markup=wallet_menu_inl(bch, wallet_id))


async def remove_addr_check(call):
    if call.data.endswith('remove_address'):
        bch, wallet_id = call.data.split('_')[:2]
        addr = await db.get_address_by_id(call.message.chat.id, int(wallet_id))
        return {'bch': bch, 'address': addr}


# —É–¥–∞–ª–µ–Ω–∏–µ –∫–æ—à–µ–ª—å–∫–∞
@dp.callback_query_handler(remove_addr_check)
async def on_address_remove(call, bch, address):
    await db.remove_wallet(call.message.chat.id, bch, address)
    text, btn = await my_bch_wallets(call, bch)
    await call.message.edit_text(text, reply_markup=btn)


async def set_wallet_name_check(call):
    if call.data.endswith('set_address_name'):
        bch, wallet_id = call.data.split('_')[:2]
        addr = await db.get_address_by_id(call.message.chat.id, int(wallet_id))
        return {'bch': bch, 'address': addr}


# –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –∑–∞–¥–∞—Ç—å –∏–º—è –∫–æ—à–µ–ª—å–∫—É
@dp.callback_query_handler(set_wallet_name_check)
async def on_set_wallet_name(call: CallbackQuery, bch, address):
    await call.message.delete()
    text = _('*–ó–∞–¥–∞–π—Ç–µ –∏–º—è –∫–æ—à–µ–ª—å–∫—É*') + '\n\n'
    await bot.send_message(call.message.chat.id, text,
                           reply_markup=remove_btn())

    text = _('–í–≤–µ–¥–∏—Ç–µ –∏–º—è –Ω–∏–∂–µ (–Ω–µ –±–æ–ª–µ–µ 20 —Å–∏–º–≤–æ–ª–æ–≤)')
    await bot.send_message(call.message.chat.id, text, reply_markup=cancel_inl())

    await storage.set_state(user=call.message.chat.id, state='input_address_name')
    await storage.set_data(user=call.message.chat.id,
                           data={'bch': bch, 'address': address})


def select_bch_check(call: CallbackQuery):
    if call.data.endswith('add_bch_wallet'):
        return {'bch': call.data.split('_')[0]}


def choice_method_check(call: CallbackQuery):
    if call.data.endswith('choice_method_add_wallet'):
        return {'bch': call.data.split('_')[0]}


# –≤—ã–±–æ—Ä —Å–ø–æ—Å–æ–±–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –∫–æ—à–µ–ª—å–∫–∞
@dp.callback_query_handler(choice_method_check)
async def on_choice_method(call, bch):
    text = _('*–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∫–æ—à–µ–ª—å–∫–∞*') + f'* {bch.capitalize()}*' + '\n\n'
    text += _('–í—ã–±–µ—Ä–∏—Ç–µ —Å–ø–æ—Å–æ–± –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –∫–æ—à–µ–ª—å–∫–∞')
    btn = choice_method_add_wallet_inl(bch)
    await call.message.edit_text(text, reply_markup=btn)


# –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –≤–≤–µ—Å—Ç–∏ –≤ –ø–æ–ª–µ –≤–≤–æ–¥–∞ –∞–¥—Ä–µ—Å –∫–æ—à–µ–ª—å–∫–∞
@dp.callback_query_handler(select_bch_check)
async def on_add_wallet(call: CallbackQuery, bch):
    await call.message.delete()

    text = _('*–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∫–æ—à–µ–ª—å–∫–∞*') + f'* {bch.capitalize()}*'
    await bot.send_message(call.message.chat.id, text,
                           reply_markup=remove_btn())

    text = _('–û—Ç–ø—Ä–∞–≤—å—Ç–µ –∞–¥—Ä–µ—Å –∫–æ—à–µ–ª—å–∫–∞')
    await bot.send_message(call.message.chat.id, text,
                           reply_markup=cancel_inl(),
                           parse_mode='markdown')

    await storage.set_state(user=call.from_user.id, state=f'{bch}_addr_input')


# —Ä–µ–∞–∫—Ü–∏—è –Ω–∞ –≤–≤–æ–¥ –∫–æ—à–µ–ª—å–∫–∞
@dp.message_handler(state='ethereum_addr_input')
@dp.message_handler(state='tron_addr_input')
async def on_input_address(msg: Message, state: FSMContext):
    bch = (await state.get_state()).split('_')[0]
    if bch == 'ethereum' and not eth.is_address(msg.text) or \
            bch == 'tron' and not trx.is_address(msg.text):
        await bot.send_message(msg.chat.id, _('*–ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –∞–¥—Ä–µ—Å*'))
        return
    await db.add_bch_address(msg.chat.id, bch, msg.text)
    await bot.send_message(msg.chat.id, _('*–ö–æ—à–µ–ª–µ–∫ –¥–æ–±–∞–≤–ª–µ–Ω*'))
    await state.reset_state()
    text, btn = main_menu()
    await bot.send_message(call.message.chat.id, text, reply_markup=btn)


async def input_address_name_check(msg):
    data = await storage.get_data(user=msg.chat.id)
    return {'bch': data['bch'], 'address': data['address']}


# –ø—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç–∏ –∏–º–µ–Ω–∏ –∫–æ—à–µ–ª—å–∫–∞
@dp.message_handler(input_address_name_check, state='input_address_name')
async def on_input_addres_name(msg, bch, address):
    if len(msg.text) > 20:
        await bot.send_message(msg.chat.id, _('*–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç*'))
        return
    await db.set_wallet_name(msg.chat.id, bch, address, msg.text)
    await bot.send_message(msg.chat.id, _('–ò–º—è `{name}` –∑–∞–¥–∞–Ω–æ').format(name=msg.text),
                           reply_markup=main_menu_btn())
    await storage.reset_state(user=msg.chat.id)
    text, btn = await my_bch_wallets(msg, bch)
    await bot.send_message(msg.chat.id, text, reply_markup=btn)


def private_key_check(call):
    if call.data.endswith('import_private_key'):
        return {'bch': call.data.split('_')[0]}


# –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—Ä–∏–≤–∞—Ç–Ω–æ–≥–æ –∫–ª—é—á–∞
@dp.callback_query_handler(private_key_check)
async def on_private_key(call: CallbackQuery, bch):
    await call.message.delete()
    text = _('–ò–º–ø–æ—Ä—Ç –ø—Ä–∏–≤–∞—Ç–Ω–æ–≥–æ –∫–ª—é—á–∞ {bch}').format(bch=bch.capitalize()) + '\n\n'
    text += _('–í—Å—Ç–∞–≤—å—Ç–µ –ø—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á')
    await bot.send_message(call.from_user.id, text, reply_markup=remove_btn())
    await storage.set_state(user=call.from_user.id, state='import_private_key')
    await storage.set_data(user=call.message.chat.id,
                           data={'bch': bch})


def generate_wallet_check(call):
    if call.data.endswith('generate_wallet'):
        return {'bch': call.data.split('_')[0]}


@dp.callback_query_handler(generate_wallet_check)
async def on_generate_wallet(call: CallbackQuery, bch):
    bch_module = bch_modules[bch]
    public_key, private_key = await bch_module.create_wallet()
    await db.add_bch_address_with_pkey(call.from_user.id, bch, public_key, private_key)
    text = _('*–í–∞—à –Ω–æ–≤—ã–π {bch}-–∫–æ—à–µ–ª–µ–∫*').format(bch=bch.capitalize()) + '\n\n'
    text += _('*–ê–¥—Ä–µ—Å:* ') + '`{}`'.format(public_key) + '\n\n'
    text += '_{}_'.format(_('–ö–æ—à–µ–ª–µ–∫ —Å–æ—Ö—Ä–∞–Ω–µ–Ω. –ü—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á –¥–æ—Å—Ç—É–ø–µ–Ω –∏–∑ –º–µ–Ω—é –∫–æ—à–µ–ª—å–∫–∞'))
    await call.message.edit_text(text)


@dp.message_handler(state='import_private_key')
async def on_input_private_key(msg):
    bch = (await storage.get_data(user=msg.chat.id))['bch']
    bch_module = bch_modules[bch]
    try:
        address = await bch_module.get_addr_from_pkey(msg.text)
    except ValueError:
        await bot.send_message(msg.chat.id, _('*–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –ø—Ä–∏–≤–∞—Ç–Ω–æ–≥–æ –∫–ª—é—á–∞*'))
    else:
        await db.add_bch_address_with_pkey(msg.chat.id, bch, address, msg.text)
        text = _('*–ö–æ—à–µ–ª–µ–∫ –¥–æ–±–∞–≤–ª–µ–Ω*') + '\n\n'
        text += _('_–†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è —É–¥–∞–ª–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –ø—Ä–∏–≤–∞—Ç–Ω—ã–º –∫–ª—é—á–æ–º')
        await bot.send_message(msg.chat.id, text)
        await storage.reset_state(user=msg.chat.id)
        btn, text = main_menu()
        await bot.send_message(msg.chat.id, text, reply_markup=btn)


executor.start_polling(dp)
